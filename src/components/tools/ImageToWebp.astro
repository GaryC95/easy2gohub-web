---
/**
 * Image to WebP – Pro
 * Batch convert to WebP locally · Quality · Optional resize · ZIP download
 *
 * Reads Settings DOM:
 * - quality
 * - maxDim
 * - resizeMode
 * - allowUpscale
 * - nameSuffix
 */
---

<section class="tool-card p-10 space-y-10">
  <div class="text-center">
    <h2 class="text-3xl font-extrabold text-slate-900">Image to WebP Converter</h2>
    <p class="text-slate-500 mt-2 text-lg">
      Convert images to WebP locally for better web performance. No upload. 100% private.
    </p>
  </div>

  <div
    id="dropzone"
    class="border-2 border-dashed border-indigo-500/30 rounded-2xl bg-white/40
           hover:bg-indigo-50/40 hover:border-indigo-500 transition-all
           cursor-pointer h-72 flex flex-col items-center justify-center text-center"
  >
    <div class="size-20 bg-indigo-500/10 rounded-full flex items-center justify-center text-indigo-600 mb-6">
      <span class="material-symbols-outlined text-4xl">image</span>
    </div>

    <h3 class="text-xl font-extrabold text-slate-800 mb-2">Drop images here</h3>
    <p class="text-sm text-slate-400 mb-6">PNG, JPG, JPEG, WEBP</p>

    <button
      id="selectBtn"
      class="bg-indigo-600 text-white px-10 py-3 rounded-full font-extrabold text-sm
             shadow-lg shadow-indigo-600/25 hover:bg-indigo-700 transition-all"
    >
      Select from computer
    </button>

    <input id="fileInput" type="file" accept="image/*" multiple class="hidden" />
  </div>

  <div id="queue" class="hidden space-y-3"></div>

  <div class="flex justify-between items-center pt-6 border-t border-slate-200/60">
    <div class="text-xs text-slate-400 font-extrabold uppercase tracking-wider">
      Status:
      <span id="status" class="text-emerald-600">Idle</span>
      <span id="statHint" class="ml-2"></span>
    </div>

    <div class="flex gap-3">
      <button id="clearBtn" class="btn-secondary" disabled>Clear</button>
      <button id="zipBtn" class="btn-secondary" disabled>Download ZIP</button>
      <button id="processBtn" class="btn-primary" disabled>Convert to WebP</button>
    </div>
  </div>

  <canvas id="canvas" class="hidden"></canvas>
</section>

<script type="module">
  const fileInput = document.getElementById("fileInput");
  const dropzone = document.getElementById("dropzone");
  const selectBtn = document.getElementById("selectBtn");
  const queueEl = document.getElementById("queue");
  const processBtn = document.getElementById("processBtn");
  const clearBtn = document.getElementById("clearBtn");
  const zipBtn = document.getElementById("zipBtn");
  const statusEl = document.getElementById("status");
  const statHint = document.getElementById("statHint");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  // Settings
  const qualityEl = document.getElementById("quality");
  const maxDimEl = document.getElementById("maxDim");
  const resizeModeEl = document.getElementById("resizeMode");
  const allowUpscaleEl = document.getElementById("allowUpscale");
  const nameSuffixEl = document.getElementById("nameSuffix");

  const MAX_SIZE = 25 * 1024 * 1024;
  let items = [];

  const fmt = (n) => {
    const u = ["B","KB","MB"];
    let i = 0;
    while (n >= 1024 && i < u.length-1) { n/=1024; i++; }
    return `${n.toFixed(1)} ${u[i]}`;
  };

  function addFiles(list) {
    for (const f of list) {
      if (!f.type.startsWith("image/")) continue;
      if (f.size > MAX_SIZE) continue;
      items.push({ file: f, blob: null });
    }
    render();
  }

  function render() {
    queueEl.innerHTML = "";
    if (!items.length) {
      queueEl.classList.add("hidden");
      processBtn.disabled = clearBtn.disabled = zipBtn.disabled = true;
      statusEl.textContent = "Idle";
      return;
    }

    queueEl.classList.remove("hidden");
    processBtn.disabled = clearBtn.disabled = false;
    zipBtn.disabled = !items.some(i => i.blob);
    statusEl.textContent = "Ready";
    statHint.textContent = `• ${items.length} file(s)`;

    items.forEach((it, i) => {
      const row = document.createElement("div");
      row.className = "flex justify-between bg-white/70 rounded-xl p-3 text-sm";
      row.innerHTML = `
        <div>
          <div class="font-bold">${it.file.name}</div>
          <div class="text-xs text-slate-400">
            ${fmt(it.file.size)} ${it.blob ? "→ " + fmt(it.blob.size) : ""}
          </div>
        </div>
        <button data-i="${i}" class="text-red-500 font-bold">✕</button>
      `;
      row.querySelector("button").onclick = () => {
        items.splice(i,1); render();
      };
      queueEl.appendChild(row);
    });
  }

  async function convertOne(file) {
    const bmp = await createImageBitmap(file);
    let w = bmp.width, h = bmp.height;

    const maxDim = Number(maxDimEl?.value || 0);
    const allowUpscale = allowUpscaleEl?.checked;
    if (maxDim && (w > maxDim || h > maxDim)) {
      const s = Math.min(maxDim / w, maxDim / h);
      w = Math.round(w * s);
      h = Math.round(h * s);
    }

    canvas.width = w;
    canvas.height = h;
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(bmp,0,0,w,h);

    const q = Number(qualityEl?.value || 80) / 100;
    return new Promise(res => canvas.toBlob(res, "image/webp", q));
  }

  async function processAll() {
    statusEl.textContent = "Processing…";
    const suffix = nameSuffixEl?.value || "-webp";

    for (const it of items) {
      const blob = await convertOne(it.file);
      it.blob = blob;
      it.name = it.file.name.replace(/\.[^.]+$/, "") + suffix + ".webp";
    }
    zipBtn.disabled = false;
    statusEl.textContent = "Done";
    render();
  }

  zipBtn.onclick = async () => {
    const { default: JSZip } = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
    const zip = new JSZip();
    items.forEach(it => zip.file(it.name, it.blob));
    const out = await zip.generateAsync({ type:"blob" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(out);
    a.download = "images-webp.zip";
    a.click();
  };

  selectBtn.onclick = () => fileInput.click();
  fileInput.onchange = () => addFiles(fileInput.files);
  dropzone.ondragover = e => e.preventDefault();
  dropzone.ondrop = e => { e.preventDefault(); addFiles(e.dataTransfer.files); };
  clearBtn.onclick = () => { items = []; render(); };
  processBtn.onclick = processAll;
</script>
